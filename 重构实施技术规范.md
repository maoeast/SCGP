# SIC-ADS 2.0 重构实施技术规范 (Implementation Spec)

**文档状态**: 正式版 V1.1 (含首席实施工程师补充)
**最后更新**: 2026-02-05
**架构核心**: Local-First, No-Native-Deps, Worker-Driven
**目标**: 构建高性能、高扩展、零原生依赖的资源管理底座。

---

## 1. 核心目标 (Objectives)

本项目旨在将现有的 "感官能力发展系统 (SIC-ADS)" 从单一垂直应用转型为 **"多系统融合的综合康复平台"**。

**关键驱动力**:
*   **业务扩展**: 支持未来接入 **"情绪调节"**、**"社交沟通"**、**"认知发展"** 等新业务模块。
*   **架构泛化**: 消除硬编码，通过 **"核心底座 + 业务模块"** 模式，实现新模块的快速插拔。
*   **用户赋能**: 开放 **"用户自定义资源"** 功能，允许一线教师扩展训练素材。

## 2. 总体架构设计 (Architecture)

采用 **Core Kernel + Business Modules** 设计模式：

*   **Core Kernel (公共底座)**:
    *   **资源管理**: 统一管理所有图片、视频、器材、剧本等素材。
    *   **档案中心**: 统一的学生档案、评估索引、训练记录流水。
    *   **系统服务**: 文件存储、用户鉴权、License 授权管理、路由分发。
*   **Business Modules (业务模块)**:
    *   **Sensory (感官)**: 现有的 Conners, CSIRS, 感官游戏, 感官器材。
    *   **Emotional (情绪)**: 规划中的 CBCL, SDQ, 情绪卡片, 表情识别游戏。
    *   **Social (社交)**: 规划中的社交剧本, 沟通板。
    *   **Life Skills (生活自理)**: 现有的 S-M, WeeFIM。

---

## 3. 架构核心原则 (Architectural Principles)

1.  **零原生依赖 (Zero Native Dependencies)**:
    *   严禁引入 `sharp`, `sqlite3` (native bindings) 等需要 `node-gyp` 编译的库。
    *   确保项目在 Windows/macOS/Linux 跨平台构建时的纯净性和稳定性。
2.  **主线程解放 (UI Thread Liberation)**:
    *   **数据库层**: sql.js 实例必须运行在 **Web Worker** 或 **Shared Worker** 中。
    *   **图像处理**: 图片压缩与转码必须运行在 **Web Worker** 中 (OffscreenCanvas)。
3.  **数据完整性 (Data Integrity)**:
    *   采用 **原子写入 (Atomic Write)** 策略防止断电损毁。
    *   采用 **防抖保存 (Debounced Save)** 减少磁盘 I/O。

---

## 4. 数据库设计 (Phase 1: Database Generalization)

### 4.1. 实体关系模型 (ER Schema)

废弃 JSON 存储标签的方案，改用标准关系模型。

```sql
-- 1. 核心资源表
CREATE TABLE sys_training_resource (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  parent_id INTEGER,              -- 支持克隆/变体
  module_code TEXT NOT NULL,      -- 'sensory', 'emotional'
  resource_type TEXT NOT NULL,    -- 'equipment', 'flashcard'
  name TEXT NOT NULL,
  category TEXT,                  -- 业务分类 Key
  description TEXT,
  cover_image TEXT,               -- 相对路径: 'resource_assets/uuid.webp'
  is_custom INTEGER DEFAULT 0,    -- 1=用户自定义
  is_active INTEGER DEFAULT 1,
  
  -- 迁移溯源
  legacy_id INTEGER,              -- 原 equipment_catalog ID
  legacy_source TEXT,             -- 'equipment_catalog'
  
  meta_data TEXT,                 -- JSON: 扩展属性
  usage_count INTEGER DEFAULT 0,  -- [新] 资源热度，用于"常用资源"排序
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP
);

-- 2. 标签字典表 (标准化)
CREATE TABLE sys_tags (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  domain TEXT NOT NULL,           -- 'ability'(能力), 'symptom'(症状)
  name TEXT NOT NULL,             -- '手眼协调'
  usage_count INTEGER DEFAULT 0,  -- 热度统计
  is_preset INTEGER DEFAULT 1,
  UNIQUE(domain, name)
);

-- 3. 资源-标签关联表
CREATE TABLE sys_resource_tag_map (
  resource_id INTEGER NOT NULL,
  tag_id INTEGER NOT NULL,
  PRIMARY KEY (resource_id, tag_id),
  FOREIGN KEY (resource_id) REFERENCES sys_training_resource(id) ON DELETE CASCADE,
  FOREIGN KEY (tag_id) REFERENCES sys_tags(id) ON DELETE CASCADE
);

-- 4. 全文检索虚拟表 (FTS5)
-- 注意: 初始化时需检测 FTS5 支持情况，不支持则降级忽略
CREATE VIRTUAL TABLE IF NOT EXISTS sys_resource_fts USING fts5(
  name, 
  description, 
  content='sys_training_resource', 
  content_rowid='id'
);

-- 触发器: 保持 FTS 同步
CREATE TRIGGER sys_resource_ai AFTER INSERT ON sys_training_resource BEGIN
  INSERT INTO sys_resource_fts(rowid, name, description) VALUES (new.id, new.name, new.description);
END;
CREATE TRIGGER sys_resource_ad AFTER DELETE ON sys_training_resource BEGIN
  INSERT INTO sys_resource_fts(sys_resource_fts, rowid, name, description) VALUES('delete', old.id, old.name, old.description);
END;
CREATE TRIGGER sys_resource_au AFTER UPDATE ON sys_training_resource BEGIN
  INSERT INTO sys_resource_fts(sys_resource_fts, rowid, name, description) VALUES('delete', old.id, old.name, old.description);
  INSERT INTO sys_resource_fts(rowid, name, description) VALUES (new.id, new.name, new.description);
END;
```

### 4.2. 数据库持久化服务 (DatabasePersistenceService)

由于 sql.js 是内存数据库，持久化策略至关重要。

*   **运行环境**: 渲染进程主线程 (Render Process) *[Plan B: 由于 Worker 加载 sql.js 的兼容性问题，已降级为主线程执行]*
*   **状态机**: `Idle` -> `Dirty` -> `Saving` -> `Saved`。
*   **防抖逻辑**: 2秒防抖，避免频繁 I/O。
*   **原子写入流程**:
    1.  `SQLWrapper` 监控写操作 -> 重置防抖定时器。
    2.  定时器触发 -> 主线程执行 `db.export()` 获取 Buffer。
    3.  主线程调用 `window.electronAPI.saveDatabaseAtomic(buffer)` 发送给 Electron 主进程。
    4.  Electron 主进程执行 `fs.fsync` + `fs.rename` 确保落盘。

### 4.3. 辅助与配置表 (Auxiliary Schema)

为了支持完整的备份恢复与个性化体验，引入统一收藏与配置存储。

```sql
-- 5. 统一收藏夹 (替代 teacher_fav)
CREATE TABLE sys_favorites (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  resource_id INTEGER NOT NULL,
  created_at TEXT DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(user_id, resource_id),
  FOREIGN KEY (resource_id) REFERENCES sys_training_resource(id) ON DELETE CASCADE
);

-- 6. 系统配置表 (KV存储)
-- 用于存储各模块的配置项，随数据库一起备份，优于 localStorage
CREATE TABLE sys_app_settings (
  module_code TEXT NOT NULL,      -- 'global', 'sensory', 'emotional'
  key TEXT NOT NULL,              -- 'default_duration', 'theme_color'
  value TEXT,                     -- JSON Value
  description TEXT,
  updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (module_code, key)
);
```

---

## 5. 资源管理系统 (Phase 2: Resource Management)

### 5.1. 自定义协议 (Security & Protocol)

在 `electron/main.ts` 中注册 `resource://` 协议。

*   **Privileges**: 配置 `secure: true`, `supportFetchAPI: true`, `standard: true`。
*   **Handler**: 拦截 `resource://` 请求，映射到 `userData/resource_assets/`。
*   **安全**: 必须检查路径，防止目录遍历攻击。

### 5.2. 图像处理管道 (Image Pipeline)

在 **Render Process** 的 **Web Worker** 中实现，避免阻塞 UI。

*   **输入**: `File` 对象 (用户上传)。
*   **处理库**: `browser-image-compression` (纯 JS) 或手动 `OffscreenCanvas`。
*   **逻辑**:
    1.  **Resize**: 长边缩放至 1024px。
    2.  **Convert**: 导出为 `image/webp` (quality: 0.8)。
    3.  **Output**: 生成 `Blob` -> `ArrayBuffer`。
*   **传输**: IPC 发送给主进程保存。

### 5.3. 孤儿文件清理 (Orphan Cleanup)

当用户删除资源时：
1.  **数据库**: 删除 `sys_training_resource` 记录。
2.  **Hook**: 触发 `afterDelete` 钩子。
3.  **IPC**: 通知主进程 `fs.unlink` 删除物理文件。

### 5.4. 模块注册与量表映射 (Module Registry & Mapping)

建立全局配置中心 `src/config/modules.ts`，实现业务模块的元数据管理与路由分发。

```typescript
export const SystemModules = {
  SENSORY: {
    code: 'sensory',
    name: '感官综合训练系统',
    assessments: ['csirs', 'conners_psq', 'conners_trs'],
    resourceCategories: ['tactile', 'vestibular', 'proprioceptive', 'visual', 'auditory'],
    iepStrategy: 'SensoryIEPStrategy'
  },
  EMOTIONAL: {
    code: 'emotional',
    name: '情绪调节系统',
    assessments: ['cbcl', 'sdq'], // Achenbach, 长处与困难
    resourceCategories: ['emotion_cards', 'calming_tools', 'expression_games'],
    iepStrategy: 'EmotionalIEPStrategy'
  },
  SOCIAL: {
    code: 'social',
    name: '社交沟通系统',
    assessments: ['social_responsiveness_scale'], 
    resourceCategories: ['social_stories', 'communication_boards'],
    iepStrategy: 'SocialIEPStrategy'
  },
  COGNITIVE: {
    code: 'cognitive',
    name: '认知发展系统',
    assessments: ['cognitive_assessment_battery'],
    resourceCategories: ['puzzles', 'memory_cards', 'sequencing'],
    iepStrategy: 'CognitiveIEPStrategy'
  },
  LIFE_SKILLS: {
    code: 'life_skills',
    name: '生活自理适应系统',
    assessments: ['sm', 'weefim'],
    resourceCategories: ['daily_living_tools', 'hygiene_kits'],
    iepStrategy: 'LifeSkillsIEPStrategy'
  }
}
```

*   **动态路由**: `router/index.ts` 将根据 License 授权状态，动态加载对应模块的路由表。
*   **资源筛选**: `ResourceSelector` 组件将根据当前激活的 `module_code` 自动过滤 `sys_training_resource`。

---

## 6. 备份与迁移策略 (Backup & Migration)

### 6.1. 流式备份 (Streaming Backup)

在 Main Process 中实现 `DataBackupService`。

*   **依赖**: `archiver` (纯 JS 流式压缩)。
*   **流程**:
    1.  **挂起写入**: 通知 Worker 暂停写入，强制 Flush。
    2.  **锁定**: 内存中标记 `isBackingUp = true`。
    3.  **流式打包**: 将 `database.sqlite` 和 `resource_assets/` 打包为 `.zip`。
    4.  **解锁**: 恢复写入。

### 6.2. 安全迁移脚本

*   **Dry Run**: 迁移脚本需支持 `--dry-run` 参数。
*   **强制备份**: 迁移开始前，Main Process 必须先 `fs.copyFile('database.db', 'database.db.bak')`。

---

## 7. 风险评估与缓解措施 (Risk Assessment & Mitigation)

### 7.1. Web Worker 通讯开销风险

**问题描述**: 所有数据库操作都经过 postMessage，频繁调用会产生序列化开销。

**缓解措施**:
```typescript
// 1. 引入批量操作接口
interface BatchOperation {
  sql: string
  params?: any[]
}

interface WorkerMessage {
  type: 'batch_execute' | 'single_execute'
  payload: {
    operations: BatchOperation[]
    id?: string  // 用于追踪
  }
}

// 2. 实现 Command Queue，合并相邻操作
class DatabaseCommandQueue {
  private queue: WorkerMessage[] = []
  private flushTimer: NodeJS.Timeout | null = null

  enqueue(message: WorkerMessage) {
    this.queue.push(message)
    if (!this.flushTimer) {
      this.flushTimer = setTimeout(() => this.flush(), 50)  // 50ms 合并窗口
    }
  }

  private flush() {
    if (this.queue.length > 0) {
      const batched = this.queue.length > 1
        ? { type: 'batch_execute', payload: { operations: this.queue } }
        : this.queue[0]
      worker.postMessage(batched)
      this.queue = []
    }
    this.flushTimer = null
  }
}

// 3. 考虑 SharedArrayBuffer (需要 COOP/COEP 头)
// 在 electron/main.ts 中配置:
app.on('ready', () => {
  session.defaultSession.webSession.setPermissionRequestHandler(...)
  // 设置 COOP/COEP 头以启用 SharedArrayBuffer
})
```

### 7.2. FTS5 兼容性风险

**问题描述**: sql.js 的 FTS5 支持取决于编译时的 Emscripten 配置，可能不可用。

**缓解措施**:
```typescript
// 1. 明确检测 FTS5 支持
function detectFTS5Support(db: Database): boolean {
  try {
    const result = db.exec("SELECT fts5()")
    return result.length > 0
  } catch (e) {
    console.warn('FTS5 not available, falling back to LIKE queries')
    return false
  }
}

// 2. 提供基于 LIKE/GLOB 的降级查询方案
class ResourceSearchService {
  private useFTS5: boolean

  constructor(private db: Database) {
    this.useFTS5 = detectFTS5Support(db)
  }

  search(query: string): Resource[] {
    if (this.useFTS5) {
      return this.db.exec(`
        SELECT r.* FROM sys_training_resource r
        JOIN sys_resource_fts f ON r.id = f.rowid
        WHERE sys_resource_fts MATCH ?
      `, [query])
    } else {
      return this.db.exec(`
        SELECT * FROM sys_training_resource
        WHERE name LIKE ? OR description LIKE ?
      `, [`%${query}%`, `%${query}%`])
    }
  }
}

// 3. 在初始化时记录警告
if (!detectFTS5Support(db)) {
  console.warn(`
    [DEGRADED] FTS5 不可用，全文检索功能将使用 LIKE 查询。
    搜索性能会降低，建议升级 sql.js 版本或使用支持 FTS5 的构建。
  `)
}
```

### 7.3. 迁移复杂性风险

**问题描述**: equipment_catalog -> sys_training_resource 的迁移涉及大量数据和关联关系。

**缓解措施**:
```sql
-- 1. 迁移前验证脚本
-- 文件: src/database/migration/verify-before-migrate.sql

-- 检查待迁移数据量
SELECT 'equipment_catalog count:' as check_item, COUNT(*) as value FROM equipment_catalog
UNION ALL
SELECT 'training_records count:', COUNT(*) FROM equipment_training_records
UNION ALL
SELECT 'teacher_fav count:', COUNT(*) FROM teacher_fav;

-- 检查 ability_tags 格式
SELECT
  CASE
    WHEN json_valid(ability_tags) THEN 'VALID'
    ELSE 'INVALID'
  END as tags_status,
  COUNT(*)
FROM equipment_catalog
GROUP BY tags_status;

-- 检查孤儿记录
SELECT 'Orphan records (no category):' as check_item,
  COUNT(*) FROM equipment_catalog WHERE category IS NULL
```

```typescript
// 2. 迁移验证脚本
// 文件: src/database/migration/migration-verification.ts

export async function verifyMigration(db: Database): Promise<VerificationReport> {
  const report: VerificationReport = {
    passed: true,
    checks: []
  }

  // 检查资源数量
  const oldCount = db.exec('SELECT COUNT(*) FROM equipment_catalog')[0].values[0][0] as number
  const newCount = db.exec('SELECT COUNT(*) FROM sys_training_resource WHERE legacy_source = "equipment_catalog"')[0].values[0][0] as number

  report.checks.push({
    name: 'Resource count match',
    expected: oldCount,
    actual: newCount,
    passed: oldCount === newCount
  })

  // 检查标签迁移
  const tagMappings = db.exec('SELECT COUNT(*) FROM sys_resource_tag_map')[0].values[0][0] as number
  report.checks.push({
    name: 'Tag mappings created',
    expected: 'at_least_1',
    actual: tagMappings,
    passed: tagMappings >= 1
  })

  // 检查收藏夹迁移
  const favOldCount = db.exec('SELECT COUNT(*) FROM teacher_fav')[0].values[0][0] as number
  const favNewCount = db.exec('SELECT COUNT(*) FROM sys_favorites')[0].values[0][0] as number

  report.checks.push({
    name: 'Favorites migration',
    expected: favOldCount,
    actual: favNewCount,
    passed: favOldCount === favNewCount
  })

  report.passed = report.checks.every(c => c.passed)
  return report
}

// 3. Rollback 脚本
// 文件: src/database/migration/rollback-migration.sql

BEGIN;

-- 删除新表
DROP TABLE IF EXISTS sys_resource_tag_map;
DROP TABLE IF EXISTS sys_training_resource;
DROP TABLE IF EXISTS sys_tags;
DROP TABLE IF EXISTS sys_favorites;
DROP TABLE IF EXISTS sys_app_settings;

-- 恢复旧表结构（如果有修改）
-- ...

COMMIT;
```

### 7.4. 图片压缩性能风险

**问题描述**: OffscreenCanvas 在某些 Electron 版本中可能不支持。

**缓解措施**:
```typescript
// 文件: src/workers/image.worker.ts

import imageCompression from 'browser-image-compression'

class ImageProcessor {
  private useOffscreenCanvas: boolean = false

  constructor() {
    // 特性检测
    this.useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
    if (!this.useOffscreenCanvas) {
      console.warn('[ImageWorker] OffscreenCanvas 不可用，使用 browser-image-compression')
    }
  }

  async compressImage(file: File): Promise<Blob> {
    const options = {
      maxSizeMB: 1,
      maxWidthOrHeight: 1024,
      useWebWorker: true,
      fileType: 'image/webp',
      initialQuality: 0.8
    }

    try {
      // 优先使用成熟的库
      return await imageCompression(file, options)
    } catch (error) {
      console.error('[ImageWorker] browser-image-compression 失败:', error)
      // 降级方案：返回原图
      return file
    }
  }
}

// TODO: 未来可以添加 OffscreenCanvas 优化路径
// async compressImageOptimized(file: File): Promise<Blob> {
//   if (!this.useOffscreenCanvas) {
//     return this.compressImage(file)
//   }
//   // 使用 OffscreenCanvas 进行更快的处理...
// }
```

### 7.5. resource:// 协议安全风险

**问题描述**: 自定义协议处理函数必须严格校验路径，防止目录遍历攻击。

**缓解措施**:
```typescript
// 文件: electron/main.ts

import { protocol, net } from 'electron'
import path from 'path'
import fs from 'fs'

const RESOURCE_BASE_PATH = path.join(app.getPath('userData'), 'resource_assets')

// 安全的路径解析函数
function safeResolveResource(requestPath: string): string | null {
  try {
    // 移除开头的斜杠
    const relativePath = requestPath.replace(/^\/+/, '')
    const fullPath = path.resolve(RESOURCE_BASE_PATH, relativePath)

    // 检查路径是否在允许的目录内
    if (!fullPath.startsWith(RESOURCE_BASE_PATH)) {
      console.error('[Security] Path traversal attempt:', requestPath)
      return null
    }

    // 检查文件是否存在
    if (!fs.existsSync(fullPath)) {
      console.warn('[Resource] File not found:', fullPath)
      return null
    }

    // 检查是否为文件（不是目录）
    const stats = fs.statSync(fullPath)
    if (!stats.isFile()) {
      console.warn('[Security] Attempted to access directory:', fullPath)
      return null
    }

    return fullPath
  } catch (error) {
    console.error('[Resource] Path resolution error:', error)
    return null
  }
}

app.whenReady().then(() => {
  protocol.handle('resource', (request) => {
    const requestPath = new URL(request.url).pathname
    const fullPath = safeResolveResource(requestPath)

    if (!fullPath) {
      return new Response('Not Found', { status: 404, statusText: 'Not Found' })
    }

    // 记录访问日志（用于安全审计）
    console.log(`[Resource] ${request.socket.remoteAddress} -> ${requestPath}`)

    return net.fetch('file://' + fullPath)
  })
})
```

---

## 8. 架构补充设计 (Supplemental Architecture)

### 8.1. 模块接口契约 (Module Interface Contract)

为确保模块的可插拔性，定义统一的模块接口契约。

```typescript
// 文件: src/types/module.ts

export interface ModuleInterface {
  // 模块元数据
  readonly meta: ModuleMeta

  // 模块生命周期
  install(app: App): Promise<void>
  uninstall(app: App): Promise<void>

  // 数据库迁移
  migrations(): MigrationStep[]

  // 路由配置
  routes(): RouteConfig[]

  // IEP 生成策略
  iePGenerator(): IEPStrategy

  // 资源类型声明
  resourceTypes(): ResourceType[]
}

export interface ModuleMeta {
  code: string
  name: string
  version: string
  dependencies: string[]  // 依赖的其他模块
  minAppVersion: string
}

export interface MigrationStep {
  version: string
  up: (db: Database) => Promise<void>
  down: (db: Database) => Promise<void>
}

// 模块注册表
export class ModuleRegistry {
  private modules = new Map<string, ModuleInterface>()

  register(module: ModuleInterface) {
    // 检查依赖
    for (const dep of module.meta.dependencies) {
      if (!this.modules.has(dep)) {
        throw new Error(`Module ${module.meta.code} depends on ${dep} which is not registered`)
      }
    }
    this.modules.set(module.meta.code, module)
  }

  get(code: string): ModuleInterface | undefined {
    return this.modules.get(code)
  }

  async installAll(app: App) {
    // 按依赖顺序安装
    const sorted = this.topologicalSort()
    for (const module of sorted) {
      await module.install(app)
    }
  }

  private topologicalSort(): ModuleInterface[] {
    // 实现拓扑排序...
  }
}
```

### 8.2. 开发者工具面板 (Developer Tools)

```vue
<!-- 文件: src/views/devtools/ModuleDevTools.vue -->
<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { ModuleRegistry } from '@/types/module'

const modules = ref<string[]>([])
const activeModules = ref<string[]>([])
const testMode = ref(false)

onMounted(async () => {
  // 扫描已注册模块
  const registry = await ModuleRegistry.getInstance()
  modules.value = Array.from(registry.getAll()).map(m => m.meta.code)
})

async function toggleModule(code: string, enabled: boolean) {
  // 动态启用/禁用模块（仅开发环境）
  if (import.meta.env.DEV) {
    await registry.enableModule(code, enabled)
  }
}

function exportModuleData(code: string) {
  // 导出模块的测试数据
}
</script>

<template>
  <div class="module-dev-tools">
    <h3>模块管理面板</h3>
    <div class="module-list">
      <div v-for="code in modules" :key="code" class="module-item">
        <label>
          <input
            type="checkbox"
            :checked="activeModules.includes(code)"
            @change="toggleModule(code, $event.target.checked)"
          />
          {{ code }}
        </label>
        <button @click="exportModuleData(code)">导出数据</button>
      </div>
    </div>

    <div class="test-section">
      <h3>测试模式</h3>
      <label>
        <input v-model="testMode" type="checkbox" />
        启用测试数据生成
      </label>
    </div>
  </div>
</template>
```

### 8.3. 向后兼容策略 (Backward Compatibility)

```typescript
// 文件: src/database/migration/compatibility-adapter.ts

/**
 * 兼容性适配器：在新旧系统并行运行期间保持数据关联
 */
export class CompatibilityAdapter {
  /**
   * 双写验证：同时写入新旧两张表，用于验证迁移正确性
   */
  async dualWriteEquipment(
    oldApi: EquipmentAPI,
    newApi: ResourceAPI,
    data: EquipmentData
  ): Promise<void> {
    try {
      // 写入旧表
      const oldId = await oldApi.createEquipment(data)

      // 写入新表
      const newResource: ResourceInput = {
        module_code: 'sensory',
        resource_type: 'equipment',
        name: data.name,
        category: data.category,
        legacy_id: oldId,
        legacy_source: 'equipment_catalog',
        meta_data: JSON.stringify({
          ability_tags: data.ability_tags,
          original_data: data
        })
      }
      const newId = await newApi.createResource(newResource)

      // 验证关联
      console.log(`[DualWrite] old_id=${oldId} -> new_id=${newId}`)
    } catch (error) {
      console.error('[DualWrite] 失败:', error)
      throw error
    }
  }

  /**
   * 双读回退：优先从新表读取，失败时回退到旧表
   */
  async getResourceWithFallback(
    newApi: ResourceAPI,
    oldApi: EquipmentAPI,
    id: number
  ): Promise<Resource | Equipment | null> {
    try {
      // 尝试从新表读取（通过 legacy_id）
      const resource = await newApi.getResourceByLegacyId(id, 'equipment_catalog')
      if (resource) {
        return resource
      }
    } catch (e) {
      console.warn('[Fallback] 新表读取失败，尝试旧表:', e)
    }

    // 回退到旧表
    return await oldApi.getEquipment(id)
  }
}
```

---

## 9. 开发计划 (Step-by-Step)

### Phase 0: 代码审计与依赖分析 (新增)
**目标**: 在重构前全面了解现有代码结构，降低风险。

**任务清单**:
1. **DatabaseAPI 调用审计**:
   - [ ] 使用 Grep 工具搜索 `db.exec`, `db.run`, `database.query` 等调用
   - [ ] 统计每个页面/组件的数据库调用次数
   - [ ] 识别高频调用点（需要优先优化）

2. **ability_tags 使用模式分析**:
   - [ ] 搜索 `ability_tags` 的所有使用位置
   - [ ] 分析 JSON 解析和 `.join()`, `.some()` 的调用模式
   - [ ] 确保所有调用都被 `ensureArray()` 包裹

3. **数据流图绘制**:
   - [ ] 绘制评估流程的完整数据流
   - [ ] 绘制训练记录的写入流程
   - [ ] 标记所有 IPC 通讯点

**交付物**: `docs/audit-report.md` - 包含调用统计表和数据流图

---

### Phase 1: 数据库与持久化底座
1.  **数据库环境 (Plan B)**:
    *   **[已降级]** Worker 环境搭建：由于 `sql.js` 在 Vite Worker 中的加载兼容性问题，SQL 执行回退到主线程。
    *   保持 `sql.js` 初始化逻辑在渲染进程主线程中运行（`database-loader.ts`）。

2.  **Schema 迁移**:
    *   编写 SQL 脚本创建 `sys_` 开头的新表。
    *   实现 `Equipment` -> `Resource` 的数据迁移逻辑。
    *   编写迁移脚本：将 `teacher_fav` 数据迁移至 `sys_favorites`。
    *   **[新增]** 实现 FTS5 检测与降级逻辑（`ResourceSearchService`）。
    *   **[新增]** 编写迁移前验证脚本 (`verify-before-migrate.sql`)。

3.  **原子写入实现 (Plan B)**:
    *   在 Electron Main Process 实现 `SAVE_DATABASE_ATOMIC` IPC 接口。
    *   在 `SQLWrapper` (主线程) 中实现防抖保存逻辑 (`setTimeout` + `db.export` + IPC)。

---

### Phase 1.5: 数据迁移验证 (新增)
**目标**: 确保数据迁移的正确性和完整性。

**任务清单**:
1. **验证脚本**:
   - [ ] 实现 `migration-verification.ts`
   - [ ] 添加资源数量、标签映射、收藏夹的断言检查
   - [ ] 实现 `rollback-migration.sql`

2. **双写验证**:
   - [ ] 实现 `CompatibilityAdapter.dualWriteEquipment()`
   - [ ] 在开发环境启用双写模式运行 1 周
   - [ ] 对比新旧表数据一致性

3. **测试数据**:
   - [ ] 编写 `migration-test-data.ts` 生成测试场景
   - [ ] 包含边界情况：空标签、重复标签、特殊字符等

**交付物**: 验证报告 + 测试用例集

---

### Phase 2: 资源管理与文件系统
1.  **协议注册**:
    *   配置 `main.ts` 注册 `resource://` 协议。
    *   **[新增]** 实现 `safeResolveResource()` 路径安全校验。

2.  **Image Worker**:
    *   创建 `src/workers/image.worker.ts`。
    *   集成 `browser-image-compression`。
    *   **[新增]** 实现特性检测和降级方案。

3.  **文件 IO**:
    *   Electron Main Process 实现 `SAVE_ASSET` (写入) 和 `DELETE_ASSET` (删除) 接口。

4.  **前端改造**:
    *   开发 `ResourceUpload.vue` 组件，对接 Image Worker。

---

### Phase 3: 业务逻辑适配
1.  重构 `ResourceSelector` 对接新的数据库结构。
2.  重构 `IEPGenerator` 使用策略模式。
3.  **[新增]** 实现模块注册表 (`ModuleRegistry`)。
4.  **[新增]** 创建开发者工具面板 (`ModuleDevTools.vue`)。

---

### Phase 3.5: 性能基准测试 (新增)
**目标**: 确保重构后性能不低于原有水平。

**任务清单**:
1. **基准测试套件**:
   - [ ] 实现 `performance/benchmark.ts`
   - [ ] 测试场景：批量查询（1000条）、单个写入、搜索响应时间

2. **对比报告**:
   - [ ] 重构前基准测试
   - [ ] 重构后基准测试
   - [ ] 性能回归分析

3. **优化迭代**:
   - [ ] 根据测试结果优化 Worker 通讯
   - [ ] 实现查询结果缓存（如果需要）

**交付物**: `docs/performance-report.md`

---

## 10. 验收标准 (Acceptance Criteria)

每个 Phase 完成后需要满足以下条件：

### Phase 0 验收
- [ ] 审计报告包含至少 5 个高频调用点的优化建议
- [ ] 数据流图标注了所有 IPC 通讯点

### Phase 1 验收
- [ ] Worker 成功运行，所有测试用例通过
- [ ] FTS5 不可用时能降级到 LIKE 查询
- [ ] 原子写入在断电测试中不丢失数据

### Phase 1.5 验收
- [ ] 所有验证检查项通过
- [ ] 双写验证数据一致性 100%
- [ ] Rollback 脚本测试成功

### Phase 2 验收
- [ ] resource:// 协议能正确加载图片
- [ ] 路径遍历攻击测试被拦截
- [ ] 图片压缩在 100ms 内完成（1920x1080 输入）

### Phase 3 验收
- [ ] 所有模块实现 `ModuleInterface`
- [ ] 开发者工具能动态启用/禁用模块
- [ ] License 控制模块访问正常工作

### Phase 3.5 验收
- [ ] 批量查询性能不低于原系统的 90%
- [ ] 搜索响应时间 < 200ms
- [ ] 无内存泄漏（连续运行 24 小时测试）
